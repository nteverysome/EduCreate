/**
 * GamePerformanceMonitor - ÈÅäÊà≤ÊÄßËÉΩÁõ£ÊéßÁ≥ªÁµ±
 * Âü∫ÊñºÁèæÊúâ PerformanceMonitor Êì¥Â±ïÔºåÂ∞àÈñÄÁõ£ÊéßÈÅäÊà≤ÂàáÊèõÊÄßËÉΩ
 * ÂØ¶ÁèæË®òÊÜ∂È´î‰ΩøÁî®ËøΩËπ§„ÄÅËºâÂÖ•ÊôÇÈñìÂàÜÊûê„ÄÅË≠¶Â†±Á≥ªÁµ±
 */

import { PerformanceMonitor } from '../utils/performanceMonitor';

// ÊÄßËÉΩÊåáÊ®ôÈ°ûÂûã
export interface GamePerformanceMetrics {
  gameId: string;
  loadTime: number;
  memoryUsage: number;
  cpuUsage: number;
  fps: number;
  switchTime: number;
  errorCount: number;
  timestamp: Date;
}

// ÊÄßËÉΩË≠¶Â†±È°ûÂûã
export interface PerformanceAlert {
  id: string;
  type: 'memory' | 'load_time' | 'fps' | 'error' | 'switch_time';
  severity: 'low' | 'medium' | 'high' | 'critical';
  message: string;
  gameId: string;
  value: number;
  threshold: number;
  timestamp: Date;
}

// ÊÄßËÉΩÁµ±Ë®à
export interface PerformanceStats {
  totalGames: number;
  averageLoadTime: number;
  averageMemoryUsage: number;
  averageSwitchTime: number;
  totalErrors: number;
  peakMemoryUsage: number;
  slowestGame: { gameId: string; loadTime: number } | null;
  fastestGame: { gameId: string; loadTime: number } | null;
}

// Áõ£ÊéßÈÖçÁΩÆ
export interface GamePerformanceConfig {
  memoryThreshold?: number; // MB
  loadTimeThreshold?: number; // ms
  switchTimeThreshold?: number; // ms
  fpsThreshold?: number;
  errorThreshold?: number;
  alertCallback?: (alert: PerformanceAlert) => void;
  metricsRetentionDays?: number;
}

export class GamePerformanceMonitor {
  private performanceMonitor: PerformanceMonitor;
  private metrics: GamePerformanceMetrics[] = [];
  private alerts: PerformanceAlert[] = [];
  private monitoringInterval?: NodeJS.Timeout;
  private fpsCounter = 0;
  private lastFpsTime = 0;
  
  // ÈÖçÁΩÆÈÅ∏È†Ö
  private readonly config: Required<GamePerformanceConfig>;
  
  // ÂØ¶ÊôÇÁõ£ÊéßÊï∏Êìö
  private currentMetrics = {
    memoryUsage: 0,
    cpuUsage: 0,
    fps: 0,
    activeGames: 0
  };

  constructor(config: GamePerformanceConfig = {}) {
    this.config = {
      memoryThreshold: config.memoryThreshold || 400, // 400MB
      loadTimeThreshold: config.loadTimeThreshold || 2000, // 2Áßí
      switchTimeThreshold: config.switchTimeThreshold || 500, // 500ms
      fpsThreshold: config.fpsThreshold || 30,
      errorThreshold: config.errorThreshold || 5,
      alertCallback: config.alertCallback || this.defaultAlertHandler,
      metricsRetentionDays: config.metricsRetentionDays || 7
    };

    // ÂàùÂßãÂåñÂü∫Á§éÊÄßËÉΩÁõ£ÊéßÂô®
    this.performanceMonitor = new PerformanceMonitor();
    
    // ÂïüÂãïÂØ¶ÊôÇÁõ£Êéß
    this.startRealTimeMonitoring();
    
    console.log('üìä GamePerformanceMonitor ÂàùÂßãÂåñÂÆåÊàê');
    console.log(`‚ö†Ô∏è Ë≠¶Â†±ÈñæÂÄº: Ë®òÊÜ∂È´î=${this.config.memoryThreshold}MB, ËºâÂÖ•=${this.config.loadTimeThreshold}ms, ÂàáÊèõ=${this.config.switchTimeThreshold}ms`);
  }

  /**
   * Ë®òÈåÑÈÅäÊà≤ËºâÂÖ•ÊÄßËÉΩ
   */
  recordGameLoad(gameId: string, loadTime: number, memoryUsage: number): void {
    const metrics: GamePerformanceMetrics = {
      gameId,
      loadTime,
      memoryUsage,
      cpuUsage: this.getCurrentCpuUsage(),
      fps: this.currentMetrics.fps,
      switchTime: 0,
      errorCount: 0,
      timestamp: new Date()
    };

    this.metrics.push(metrics);
    
    // ‰ΩøÁî®Âü∫Á§éÊÄßËÉΩÁõ£ÊéßÂô®Ë®òÈåÑ
    this.performanceMonitor.recordMetric('game_load_time', loadTime);
    this.performanceMonitor.recordMetric('memory_usage', memoryUsage);
    
    // Ê™¢Êü•ÊòØÂê¶ÈúÄË¶ÅÁôºÂá∫Ë≠¶Â†±
    this.checkLoadTimeAlert(gameId, loadTime);
    this.checkMemoryAlert(gameId, memoryUsage);
    
    console.log(`üìà Ë®òÈåÑÈÅäÊà≤ËºâÂÖ•: ${gameId} (${loadTime}ms, ${memoryUsage}MB)`);
  }

  /**
   * Ë®òÈåÑÈÅäÊà≤ÂàáÊèõÊÄßËÉΩ
   */
  recordGameSwitch(fromGameId: string, toGameId: string, switchTime: number): void {
    const metrics: GamePerformanceMetrics = {
      gameId: toGameId,
      loadTime: 0,
      memoryUsage: this.currentMetrics.memoryUsage,
      cpuUsage: this.getCurrentCpuUsage(),
      fps: this.currentMetrics.fps,
      switchTime,
      errorCount: 0,
      timestamp: new Date()
    };

    this.metrics.push(metrics);
    
    // ‰ΩøÁî®Âü∫Á§éÊÄßËÉΩÁõ£ÊéßÂô®Ë®òÈåÑ
    this.performanceMonitor.recordMetric('game_switch_time', switchTime);
    
    // Ê™¢Êü•ÂàáÊèõÊôÇÈñìË≠¶Â†±
    this.checkSwitchTimeAlert(toGameId, switchTime);
    
    console.log(`üîÑ Ë®òÈåÑÈÅäÊà≤ÂàáÊèõ: ${fromGameId} ‚Üí ${toGameId} (${switchTime}ms)`);
  }

  /**
   * Ë®òÈåÑÈÅäÊà≤ÈåØË™§
   */
  recordGameError(gameId: string, error: string): void {
    // Êõ¥Êñ∞ÈåØË™§Ë®àÊï∏
    const recentMetrics = this.metrics.filter(m => 
      m.gameId === gameId && 
      (Date.now() - m.timestamp.getTime()) < 300000 // 5ÂàÜÈêòÂÖß
    );
    
    const errorCount = recentMetrics.reduce((sum, m) => sum + m.errorCount, 0) + 1;
    
    const metrics: GamePerformanceMetrics = {
      gameId,
      loadTime: 0,
      memoryUsage: this.currentMetrics.memoryUsage,
      cpuUsage: this.getCurrentCpuUsage(),
      fps: this.currentMetrics.fps,
      switchTime: 0,
      errorCount: 1,
      timestamp: new Date()
    };

    this.metrics.push(metrics);
    
    // Ê™¢Êü•ÈåØË™§Ë≠¶Â†±
    this.checkErrorAlert(gameId, errorCount);
    
    console.log(`‚ùå Ë®òÈåÑÈÅäÊà≤ÈåØË™§: ${gameId} - ${error}`);
  }

  /**
   * Áç≤ÂèñÈÅäÊà≤ÊÄßËÉΩÁµ±Ë®à
   */
  getPerformanceStats(): PerformanceStats {
    if (this.metrics.length === 0) {
      return {
        totalGames: 0,
        averageLoadTime: 0,
        averageMemoryUsage: 0,
        averageSwitchTime: 0,
        totalErrors: 0,
        peakMemoryUsage: 0,
        slowestGame: null,
        fastestGame: null
      };
    }

    const gameIds = [...new Set(this.metrics.map(m => m.gameId))];
    const loadTimes = this.metrics.filter(m => m.loadTime > 0);
    const switchTimes = this.metrics.filter(m => m.switchTime > 0);
    const memoryUsages = this.metrics.map(m => m.memoryUsage);
    const totalErrors = this.metrics.reduce((sum, m) => sum + m.errorCount, 0);

    // ÊâæÂá∫ÊúÄÊÖ¢ÂíåÊúÄÂø´ÁöÑÈÅäÊà≤
    const slowestGame = loadTimes.length > 0 ? 
      loadTimes.reduce((prev, curr) => prev.loadTime > curr.loadTime ? prev : curr) : null;
    const fastestGame = loadTimes.length > 0 ? 
      loadTimes.reduce((prev, curr) => prev.loadTime < curr.loadTime ? prev : curr) : null;

    return {
      totalGames: gameIds.length,
      averageLoadTime: loadTimes.length > 0 ? 
        loadTimes.reduce((sum, m) => sum + m.loadTime, 0) / loadTimes.length : 0,
      averageMemoryUsage: memoryUsages.reduce((sum, m) => sum + m, 0) / memoryUsages.length,
      averageSwitchTime: switchTimes.length > 0 ? 
        switchTimes.reduce((sum, m) => sum + m.switchTime, 0) / switchTimes.length : 0,
      totalErrors,
      peakMemoryUsage: Math.max(...memoryUsages),
      slowestGame: slowestGame ? { gameId: slowestGame.gameId, loadTime: slowestGame.loadTime } : null,
      fastestGame: fastestGame ? { gameId: fastestGame.gameId, loadTime: fastestGame.loadTime } : null
    };
  }

  /**
   * Áç≤ÂèñÁâπÂÆöÈÅäÊà≤ÁöÑÊÄßËÉΩÊåáÊ®ô
   */
  getGameMetrics(gameId: string): GamePerformanceMetrics[] {
    return this.metrics.filter(m => m.gameId === gameId);
  }

  /**
   * Áç≤ÂèñÊÄßËÉΩË≠¶Â†±
   */
  getAlerts(severity?: PerformanceAlert['severity']): PerformanceAlert[] {
    if (severity) {
      return this.alerts.filter(alert => alert.severity === severity);
    }
    return [...this.alerts];
  }

  /**
   * Ê∏ÖÈô§ËàäÁöÑÊÄßËÉΩÊåáÊ®ô
   */
  cleanupOldMetrics(): void {
    const retentionTime = this.config.metricsRetentionDays * 24 * 60 * 60 * 1000;
    const cutoffTime = Date.now() - retentionTime;
    
    const oldMetricsCount = this.metrics.length;
    this.metrics = this.metrics.filter(m => m.timestamp.getTime() > cutoffTime);
    
    const oldAlertsCount = this.alerts.length;
    this.alerts = this.alerts.filter(a => a.timestamp.getTime() > cutoffTime);
    
    console.log(`üßπ Ê∏ÖÁêÜËàäÊåáÊ®ô: ÊåáÊ®ô ${oldMetricsCount} ‚Üí ${this.metrics.length}, Ë≠¶Â†± ${oldAlertsCount} ‚Üí ${this.alerts.length}`);
  }

  /**
   * ÂïüÂãïÂØ¶ÊôÇÁõ£Êéß
   */
  private startRealTimeMonitoring(): void {
    this.monitoringInterval = setInterval(() => {
      this.updateCurrentMetrics();
      this.checkSystemAlerts();
    }, 1000); // ÊØèÁßíÊõ¥Êñ∞‰∏ÄÊ¨°

    // ÂïüÂãï FPS Áõ£Êéß
    this.startFpsMonitoring();
  }

  /**
   * Êõ¥Êñ∞Áï∂ÂâçÊåáÊ®ô
   */
  private updateCurrentMetrics(): void {
    // Êõ¥Êñ∞Ë®òÊÜ∂È´î‰ΩøÁî®
    if ((performance as any).memory) {
      this.currentMetrics.memoryUsage = (performance as any).memory.usedJSHeapSize / (1024 * 1024);
    }

    // Êõ¥Êñ∞ CPU ‰ΩøÁî®ÔºàÁ∞°Âåñ‰º∞ÁÆóÔºâ
    this.currentMetrics.cpuUsage = this.getCurrentCpuUsage();
  }

  /**
   * ÂïüÂãï FPS Áõ£Êéß
   */
  private startFpsMonitoring(): void {
    const measureFps = () => {
      this.fpsCounter++;
      const now = performance.now();
      
      if (now - this.lastFpsTime >= 1000) {
        this.currentMetrics.fps = Math.round((this.fpsCounter * 1000) / (now - this.lastFpsTime));
        this.fpsCounter = 0;
        this.lastFpsTime = now;
        
        // Ê™¢Êü• FPS Ë≠¶Â†±
        if (this.currentMetrics.fps < this.config.fpsThreshold) {
          this.createAlert('fps', 'medium', `FPS ÈÅé‰Ωé: ${this.currentMetrics.fps}`, 'system', this.currentMetrics.fps, this.config.fpsThreshold);
        }
      }
      
      requestAnimationFrame(measureFps);
    };
    
    requestAnimationFrame(measureFps);
  }

  /**
   * Áç≤ÂèñÁï∂Ââç CPU ‰ΩøÁî®ÁéáÔºàÁ∞°Âåñ‰º∞ÁÆóÔºâ
   */
  private getCurrentCpuUsage(): number {
    // ÈÄôÊòØ‰∏ÄÂÄãÁ∞°ÂåñÁöÑ CPU ‰ΩøÁî®Áéá‰º∞ÁÆó
    // ÂØ¶ÈöõÂØ¶ÁèæÂèØËÉΩÈúÄË¶ÅÊõ¥Ë§áÈõúÁöÑÈÇèËºØ
    const start = performance.now();
    let iterations = 0;
    
    while (performance.now() - start < 1) {
      iterations++;
    }
    
    // Âü∫ÊñºËø≠‰ª£Ê¨°Êï∏‰º∞ÁÆó CPU Ë≤†Ëºâ
    return Math.min(100, Math.max(0, 100 - (iterations / 1000)));
  }

  /**
   * Ê™¢Êü•ËºâÂÖ•ÊôÇÈñìË≠¶Â†±
   */
  private checkLoadTimeAlert(gameId: string, loadTime: number): void {
    if (loadTime > this.config.loadTimeThreshold) {
      const severity = loadTime > this.config.loadTimeThreshold * 2 ? 'high' : 'medium';
      this.createAlert('load_time', severity, `ËºâÂÖ•ÊôÇÈñìÈÅéÈï∑: ${loadTime}ms`, gameId, loadTime, this.config.loadTimeThreshold);
    }
  }

  /**
   * Ê™¢Êü•Ë®òÊÜ∂È´îË≠¶Â†±
   */
  private checkMemoryAlert(gameId: string, memoryUsage: number): void {
    if (memoryUsage > this.config.memoryThreshold) {
      const severity = memoryUsage > this.config.memoryThreshold * 1.5 ? 'critical' : 'high';
      this.createAlert('memory', severity, `Ë®òÊÜ∂È´î‰ΩøÁî®ÈÅéÈ´ò: ${memoryUsage}MB`, gameId, memoryUsage, this.config.memoryThreshold);
    }
  }

  /**
   * Ê™¢Êü•ÂàáÊèõÊôÇÈñìË≠¶Â†±
   */
  private checkSwitchTimeAlert(gameId: string, switchTime: number): void {
    if (switchTime > this.config.switchTimeThreshold) {
      const severity = switchTime > this.config.switchTimeThreshold * 2 ? 'high' : 'medium';
      this.createAlert('switch_time', severity, `ÂàáÊèõÊôÇÈñìÈÅéÈï∑: ${switchTime}ms`, gameId, switchTime, this.config.switchTimeThreshold);
    }
  }

  /**
   * Ê™¢Êü•ÈåØË™§Ë≠¶Â†±
   */
  private checkErrorAlert(gameId: string, errorCount: number): void {
    if (errorCount > this.config.errorThreshold) {
      const severity = errorCount > this.config.errorThreshold * 2 ? 'critical' : 'high';
      this.createAlert('error', severity, `ÈåØË™§Ê¨°Êï∏ÈÅéÂ§ö: ${errorCount}`, gameId, errorCount, this.config.errorThreshold);
    }
  }

  /**
   * Ê™¢Êü•Á≥ªÁµ±Á¥öË≠¶Â†±
   */
  private checkSystemAlerts(): void {
    // Ê™¢Êü•Á∏ΩË®òÊÜ∂È´î‰ΩøÁî®
    if (this.currentMetrics.memoryUsage > this.config.memoryThreshold * 0.8) {
      this.createAlert('memory', 'medium', `Á≥ªÁµ±Ë®òÊÜ∂È´î‰ΩøÁî®Êé•ËøëÈôêÂà∂: ${this.currentMetrics.memoryUsage}MB`, 'system', this.currentMetrics.memoryUsage, this.config.memoryThreshold);
    }
  }

  /**
   * ÂâµÂª∫Ë≠¶Â†±
   */
  private createAlert(
    type: PerformanceAlert['type'],
    severity: PerformanceAlert['severity'],
    message: string,
    gameId: string,
    value: number,
    threshold: number
  ): void {
    const alert: PerformanceAlert = {
      id: `alert-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      type,
      severity,
      message,
      gameId,
      value,
      threshold,
      timestamp: new Date()
    };

    this.alerts.push(alert);
    
    // Ë™øÁî®Ë≠¶Â†±ÂõûË™ø
    this.config.alertCallback(alert);
    
    console.warn(`‚ö†Ô∏è ÊÄßËÉΩË≠¶Â†± [${severity.toUpperCase()}]: ${message}`);
  }

  /**
   * È†êË®≠Ë≠¶Â†±ËôïÁêÜÂô®
   */
  private defaultAlertHandler = (alert: PerformanceAlert): void => {
    const emoji = {
      low: 'üíõ',
      medium: 'üß°',
      high: '‚ù§Ô∏è',
      critical: 'üö®'
    }[alert.severity];
    
    console.warn(`${emoji} ÊÄßËÉΩË≠¶Â†±: ${alert.message} (${alert.gameId})`);
  };

  /**
   * ÁîüÊàêÊÄßËÉΩÂ†±Âëä
   */
  generatePerformanceReport(): string {
    const stats = this.getPerformanceStats();
    const recentAlerts = this.alerts.filter(a => 
      (Date.now() - a.timestamp.getTime()) < 24 * 60 * 60 * 1000 // 24Â∞èÊôÇÂÖß
    );

    return `
üìä EduCreate ÈÅäÊà≤ÊÄßËÉΩÂ†±Âëä
=======================

üìà Á∏ΩÈ´îÁµ±Ë®à:
- Áõ£ÊéßÈÅäÊà≤Êï∏Èáè: ${stats.totalGames}
- Âπ≥ÂùáËºâÂÖ•ÊôÇÈñì: ${Math.round(stats.averageLoadTime)}ms
- Âπ≥ÂùáË®òÊÜ∂È´î‰ΩøÁî®: ${Math.round(stats.averageMemoryUsage)}MB
- Âπ≥ÂùáÂàáÊèõÊôÇÈñì: ${Math.round(stats.averageSwitchTime)}ms
- Á∏ΩÈåØË™§Ê¨°Êï∏: ${stats.totalErrors}
- Â≥∞ÂÄºË®òÊÜ∂È´î: ${Math.round(stats.peakMemoryUsage)}MB

üèÜ ÊÄßËÉΩÊéíË°å:
- ÊúÄÂø´ËºâÂÖ•: ${stats.fastestGame ? `${stats.fastestGame.gameId} (${stats.fastestGame.loadTime}ms)` : 'N/A'}
- ÊúÄÊÖ¢ËºâÂÖ•: ${stats.slowestGame ? `${stats.slowestGame.gameId} (${stats.slowestGame.loadTime}ms)` : 'N/A'}

‚ö†Ô∏è ËøëÊúüË≠¶Â†± (24Â∞èÊôÇ):
${recentAlerts.length === 0 ? 'ÁÑ°Ë≠¶Â†±' : recentAlerts.map(a => 
  `- [${a.severity.toUpperCase()}] ${a.message} (${a.gameId})`
).join('\n')}

üìä Áï∂ÂâçÁãÄÊÖã:
- Ë®òÊÜ∂È´î‰ΩøÁî®: ${Math.round(this.currentMetrics.memoryUsage)}MB
- CPU ‰ΩøÁî®Áéá: ${Math.round(this.currentMetrics.cpuUsage)}%
- FPS: ${this.currentMetrics.fps}
- Ê¥ªË∫çÈÅäÊà≤: ${this.currentMetrics.activeGames}

ÁîüÊàêÊôÇÈñì: ${new Date().toLocaleString()}
    `.trim();
  }

  /**
   * Èä∑ÊØÄÁõ£ÊéßÂô®
   */
  destroy(): void {
    if (this.monitoringInterval) {
      clearInterval(this.monitoringInterval);
    }

    // Ê∏ÖÁêÜÊï∏Êìö
    this.metrics = [];
    this.alerts = [];

    console.log('üßπ GamePerformanceMonitor Â∑≤Èä∑ÊØÄ');
  }
}
